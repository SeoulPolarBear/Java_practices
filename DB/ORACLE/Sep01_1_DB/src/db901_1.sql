-- 테이블의 데이터를 검색, 삽입, 수정, 삭제하는데 사용하는 문장인
-- 데이터 조작어 (DML) 중에서 데이터를 넣는 명령어인 INSERT와
-- 데이터를 검색 or 조회할 수 있는 명령어인 SELECT의 구조를 뜯어봤음.

-- insert into [테이블명] values(값, 값, ... (순서에 맞춰서)) 의 형태!
-- insert를 하면서 primary key를 줄 수 없는 상황에
-- 강제적으로 고유 번호값을 만드는 방법으로 primary key를 줬었고
-- 그 고유한 번호값들을 만드는데 있어서 매번 하나하나 지정해 줄 수는 없으니
-- 번호값들을 찍어내는 공장!!! SEQUENCE 라는 기능을 활용했음 !
-- 테이블이랑 무관하고, 단점으로 INSERT에 실패하더라도, SEQUENCE의 값은 무조건 올라간다는 것 !!

-- 그 다음에 데이터를 검색할 수 있는 SELECT (쿼리 문)
-- *************회사 들어가면 가장 많이 사용하게 될, 아주 중요한 부분이라고 함.******************
-- select [distinct] [컬럼명], [컬럼명 as 별칭] 혹은 그냥 [컬럼명 별칭], [연산자 사용], [통계함수], ...
-- from [테이블명]
-- where [조건식]
-- group by [그룹대상]
-- having [함수 포함 조건]
-- order by [정렬대상 ASC/DESC]

-- distinct는 중복을 제거해주는 역할 !
-- 컬럼명에 별칭부여하는 방법 : AS를 붙이거나 아니면 띄어쓰기만 하거나
-- 연산자 시리즈 첫번째 산술연산자 (+, -, *, /), 바로 이어서 문자를 이어붙여주는 연산자 '||'
-- DUAL 더미테이블을 이용해서 유용한 내장함수(숫자함수, 문자함수, 날짜함수, 통계함수, NULL관련함수)
-- 전체 데이터 중 조건에 맞는 데이터를 찾아주는 WHERE절(조건식) 을 다루면서
-- 연산자 시리즈 두번째 비교연산자(=, !=, >, <, >=, <=)
-- 연산자 시리즈 세번째 관계연산자 AND와 BETWEEN의 차이 !
--					연속되지 않은 값들을 받아올 때 사용하는 IN, OR
--					그 반대되는 값을 받아올 때 사용하는 NOT
--					이때 NOT의 위치는 IN 앞 !!!
-- 연산자 시리즈 네번째 패턴연산자 : 문자열을 포함하는 검색
--		LIKE '%패턴%' 의 형태 / LIKE 대신 = (등호)를 사용하면 안되는 이유 !
--			=> 등호를 사용하면 패턴을 문자 그대로 인식해버리기 때문에 !
-- 연산자 시리즈 마지막 집합연산자
-- 		UNION / UNION ALL (합집합)
--			: 중복되는 값을 제외하고 출력 / 중복되더라도 모두 출력
--		INTERSECT (교집합)
--			: 집합 중 공통되는 값 출력
--		MINUS (차집합)
--			: 앞에 있는 SELECT문 중에서 뒤에 있는 SELECT문에는 없는 값 출력
-- 연산자 끝내면서 연산자의 우선순위 (왼쪽이 최우선 순위)
--		괄호 > 비교연산자 > NOT > AND > OR

-- WHERE 조건식 끝냈고
-- 다음으로는 GROUP BY : 그룹으로 묶어서 연산하여 하나의 결과를 나타내는 것 !
--		ROLLUP 연산자 : 컬럼에 대한 소계(Subtotal)를 만들어줌
-- 그 다음에 HAVING절과 WHERE절
--		: HAVING절은 그룹의 결과를 제한 / WHERE절은 조건을 사용해서 결과를 제한
-- 마지막으로 정렬을 해주는 ORDER BY 
--		: 오름차순 ASC(기본값이라 명시 안해도 됨) / 내림차순 DESC
------------------------------------------------------------------------
-- *** 서브쿼리 (SubQuery)
-- SELECT문 안에 다시 SELECT문을 사용하는 기술 !
-- 하나의 SQL문 안에 다른 SQL문이 중첩된 질의문을 말함.
-- 다른 테이블에서 가져온 데이터로 현재 테이블에 있는 정보를 찾거나 가공할 때 사용함
-- 보통 데이터가 대량일 때 데이터를 모두 합쳐서 연산하는 JOIN보다 
-- 필요한 데이터만 찾아서 공급해주는 SUBQUERY가 성능이 더 좋음

-- 주 질의 (main query, 외부 질의)와 부속 질의 (subquery, 내부 질의)로 구성됨.

--	 <main query>						 <sub query>
select s_name, s_price
	from SNACK
									where s_price < (
										select avg(s_price)
										from SNACK
);
-- 평균가보다 가격이 낮은 과자의 이름과 가격 정보를 조회한 것
-- 한 가지 팁이라면... 부분으로 나눠서 구성해보면 조금더 가독성이 좋아지고,
-- 조건에 맞게 잘 찾을 수 있음 !

-- 메인쿼리의 where절에서 서브쿼리의 결과와 비교할 때는 반드시 비교연산자를 사용해야 함 !
-- 괄호 주의 !
-- where절 이후 select문은 꼭 소괄호로 감싸줘야 함 ! 안넣으면 구문 오류

-- 과자들 중 최고가
-- 제일 비싼 과자 이름, 제조사, 가격
-- 제일 싼 과자는 어디에서 만드나요?
-- 평균가보다 비싼 과자는 몇 종류?
-- 유통기한이 가장 오래 남은 과자의 전체 정보

-- 최고가
select max(s_price) from SNACK;

-- 최고가 과자의 정보
select s_name, s_company, s_price 
	from snack
	where s_price = (
		select max(s_price) 
		from SNACK
);
			
-- 제일 싼 과자는 어디에서?
select distinct s_company
	from snack
	where s_price =(
		select min(s_price)
		from snack
);
		
-- 평균가보다 비싼 과자는 몇 종류?
select count(*) || '종류' "평균보다 비싼 과자"
	from snack
	where s_price > (
		select avg(s_price)
		from snack
);

-- 유통기한이 가장 오래 남은 과자의 전체 정보
-- date에도 max 함수 이용 가능.
select *
	from snack
	where s_exp = (
		select max(s_exp)
		from snack
);
-----------------------------------------------------------------------------------
-- 과자 회사 테이블을 만들건데, 회사이름, 주소, 직원 수 값을 가지게 만들어주세요
-- 과자 테이블에 맞춰서 데이터 넣기!
select * from SNACK;

create table aug30_maker (
	m_name varchar2(10 char) primary key,
	m_address varchar2(30 char) not null,
	m_employ_number number(5)
);

insert into aug30_maker values ('롯데', '부산', 4573);
insert into aug30_maker values ('해태', '광주', 1557);
insert into aug30_maker values ('크라운', '부천', 1307);
insert into aug30_maker values ('오리온', '서울', 1373);
insert into aug30_maker values ('동서식품', '인천', 1126);

drop table aug30_maker cascade constraint purge;

select * from aug30_maker;
----------------------------------------------------------------------------------------
-- 직원 수 제일 적은 회사에서 만드는 과자이름, 가격
-- 제일 비싼 과자를 만드는 회사는 어디에 있는지
-- 부천에 있는 회사에서 만드는 과자의 평균가
-- 평균가 이상의 과자를 만드는 회사의 이름, 위치

-- 직원 적은 회사가 만드는 과자, 가격 (서로 다른 두 테이블을 연결하려면 연결고리가 필요! -> 회사의 이름)
select s_name, s_price from SNACK where s_company = (
	select m_name from aug30_maker where m_employ_number = (
		select min(m_employ_number) from AUG30_MAKER
	)
);

-- 제일 비싼 과자를 만드는 회사의 위치?
select m_address from aug30_maker where m_name in (
	select s_company from snack where s_price = (
		select max(s_price) from snack
	)
);

-- 부천에 있는 회사에서 만드는 과자의 평균가
select avg(s_price) from snack where s_company = (
	select m_name from aug30_maker where m_address = '부천'
);		

-- 평균 이상을 만드는 회사의 이름, 위치
--select m_name, m_address from aug30_maker where m_name = (
--	select distinct s_maker from aug30_snack where s_price >= (
--		select avg(s_price) from aug30_snack
--	)
--);  
-- single-row subquery returns more than one row 에러 발생.
-- 값이 하나만 있어야 하는데, 여러개가 들어왔다.
-- 회사명이 해태거나, 롯데거나, ...
-- 문제의 원인 " = " 
-- = 쓰면 단일값 이상의 결과를 내보낼 수가 없어서 !
--		=> 관계연산자 < in > 사용.
select m_name, m_address from aug30_maker where m_name in (
	select distinct s_maker from aug30_snack where s_price >= (
		select avg(s_price) from aug30_snack
	)
);  